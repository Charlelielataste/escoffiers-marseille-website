---
import { cn } from "@/lib/utils";
import { getImage } from "astro:assets";
export interface Props {
  picture: ImageMetadata;
  pictureAlt?: string;
  has_scroll_indicator?: boolean;
  is_404?: boolean;
}

const {
  picture,
  pictureAlt = "Hero image",
  is_404 = false,
  has_scroll_indicator = true,
} = Astro.props;

const optimized = await getImage({
  src: picture,
  widths: [640, 1024, 1440, 1920],
  format: "webp",
});

const placeholder = await getImage({
  src: picture,
  width: 20,
  height: 20,
  format: "webp",
  quality: 20,
});
---

<section
  class={cn(
    "relative h-[600px] md:h-[100dvh] pt-12 md:pt-0 flex items-center justify-center overflow-hidden",
    is_404 && "h-[100dvh]"
  )}
>
  <div
    class={cn(
      "fixed w-full h-full top-[60px] sm:top-[71px] bg-cover bg-center bg-no-repeat md:scale-110",
      is_404 && "top-0 sm:top-0 h-full"
    )}
    role="img"
    aria-label={pictureAlt}
    style={`background-image: url('${placeholder.src}'); filter: blur(10px); will-change: opacity; transition: opacity 1.5s ease-out;`}
    id="hero-placeholder"
  >
  </div>

  <img
    src={optimized.src}
    srcset={optimized.srcSet.attribute}
    sizes="100vw"
    alt={pictureAlt}
    class={cn(
      "fixed w-full h-full object-cover opacity-0 top-[60px] sm:top-[71px]",
      is_404 && "top-0 sm:top-0 h-full"
    )}
    style="transition: opacity 1.2s ease-in-out; will-change: opacity;"
    id="hero-image"
    onload="window.heroImageLoaded && window.heroImageLoaded()"
  />

  <div
    class="absolute top-80 md:top-1/2 md:h-[500px] md:w-[850px] h-[350px] w-[95%] left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black/75 md:blur-3xl blur-2xl"
  >
  </div>
  <slot />

  {
    has_scroll_indicator && (
      <div
        class="hidden md:block absolute bottom-8 left-1/2 transform -translate-x-1/2 z-20"
        id="scroll-indicator"
      >
        <div class="w-6 h-10 border-2 border-white rounded-full flex justify-center backdrop-blur-sm bg-black/20">
          <div class="w-1 h-3 bg-white rounded-full mt-2 animate-bounce" />
        </div>
      </div>
    )
  }
</section>

<script>
  document.addEventListener("astro:page-load", function () {
    const heroImage = document.getElementById("hero-image") as HTMLImageElement;
    const heroPlaceholder = document.getElementById(
      "hero-placeholder"
    ) as HTMLDivElement;
    const scrollIndicator = document.getElementById(
      "scroll-indicator"
    ) as HTMLDivElement;

    if (!heroImage) return;

    const isMobile = window.innerWidth < 768;

    let ticking = false;

    function handleImageLoaded() {
      setTimeout(() => {
        heroImage.style.opacity = "1";

        setTimeout(() => {
          if (heroPlaceholder) {
            heroPlaceholder.style.opacity = "0";
          }
        }, 800);
      }, 5);
    }

    (window as any).heroImageLoaded = handleImageLoaded;

    if (heroImage.complete && heroImage.naturalHeight !== 0) {
      handleImageLoaded();
    }

    if (isMobile) {
      // Ensure no transformation is applied on mobile
      heroImage.style.transform = "none";
      return;
    }

    function updateImageScale() {
      const scrolled = window.pageYOffset;
      const maxScrollForZoom = window.innerHeight * 2;
      const progress = Math.min(scrolled / maxScrollForZoom, 1);

      const easeOut = 1 - Math.pow(1 - progress, 3);

      const minScale = 1;
      const maxScale = 1.2;
      const finalScale = minScale + (maxScale - minScale) * easeOut;

      heroImage.style.transform = `scale(${finalScale.toFixed(4)})`;

      if (scrollIndicator) {
        const indicatorOpacity = Math.max(0, 1 - scrolled / 100);
        const indicatorScale = Math.max(0.8, 1 - scrolled / 500);

        scrollIndicator.style.opacity = indicatorOpacity.toFixed(2);
        scrollIndicator.style.transform = `translate(-50%, 0) scale(${indicatorScale.toFixed(2)})`;
      }

      ticking = false;
    }

    function requestTick() {
      if (!ticking) {
        requestAnimationFrame(updateImageScale);
        ticking = true;
      }
    }

    window.addEventListener("scroll", requestTick, { passive: true });

    const heroSection = heroImage.closest("section");
    if (heroSection) {
      const observer = new IntersectionObserver(
        (entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting) {
              window.addEventListener("scroll", requestTick, {
                passive: true,
              });
            } else {
              window.removeEventListener("scroll", requestTick);
            }
          });
        },
        { rootMargin: "100px" }
      );

      observer.observe(heroSection);
    }

    updateImageScale();
  });
</script>
